# 一些算法代码


## 二分算法

* [快速排序](quick_sort.go)
* [寻找重复数](寻找重复数.go)


**旋转数组** 

<details>
<summary> 扩展阅读</summary>
对与一个旋转数组二分， 那么一定有一半是有序的。 在做题的时候你需要把握这个关键点。

</details>

  * [搜索旋转排序数组](搜索旋转排序数组.go)
  * [搜索旋转排序数组II](搜索旋转排序数组II.go)
  * [寻找旋转排序数组中的最小值](寻找旋转排序数组中的最小值.go)
  * [寻找旋转排序数组中的最小值II](寻找旋转排序数组中的最小值II.go)
  
## 链表
<details>
<summary>扩展阅读</summary>

链表环问题
你需要明白， 
* 如果两个快指针最慢指针， 其快指针一定会追上的慢指针。
* 如果快指针的速度为2， 慢指针的速度为1， 如果快慢指针距离为N， 那么在追上慢指针， 其中快指针走了2N， 慢指针走了N。

</details>

* [链表是否有环](判断链表是否有环.go)
* [链表环的入口](求链表的环入口.go)
* [两两交换链表中的节点](problem/两两交换链表中的节点.go)


## 树

* [对称二叉树](problem/对称二叉树.go)
* []

### 二叉树的打印
* [从上到下打印二叉树III](从上到下打印二叉树III.go)




## 字符串
* [验证回文串](验证回文串.go)



## Hash 表
* [最长连续序列](最长连续序列.go)



## 并查集

<details>
<summary>扩展说明</summary>

主要操作：
* 判断两个点是否在一个同一个集合里面
* 合并两个集合(merge)
其中判断两个节点的根节点相同，那么两个节点一定是在同一个节点上。

</details>

* [最长连续序列](最长连续序列c.go)


## 


## 数论
* [三数之和](三数之和.go)
* [组合总和 dfs](组合总和.go)


## 经典算法

### 无序数组，找两个和为k的数 (一次遍历怎么完成)
* 先排序，然后用两个指针，一个指向头部， 一个指向尾部， 判断是否有两个和为sum
* hash 表
* 如果 sum 不大， 可以开一个sum数组， 来统计。


### 无序整数数组中找第k大的数
* 先排序，然后输出第k大的数。
* 快排， 对数据快速的分堆，然后根据堆的数量，递归的访问另一堆。
* 二分搜索， 如果知道数组的最大和最小值， 可以二分搜索[min, max]
* 堆排序，寻找第k大的数，适用于海量数据。
* 键值索引法， 当 数组的数不大时， 可以统计每个数出现的次数，寻找k大值。



